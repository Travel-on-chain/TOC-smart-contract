// SPDX-License-Identifier: MIT

// Layout of Contract:
// version
// imports
// errors
// interfaces, libraries, contracts
// Type declarations
// State variables
// Events
// Modifiers
// Functions

// Layout of Functions:
// constructor
// receive function (if exists)
// fallback function (if exists)
// external
// public
// internal
// private
// internal & private view & pure functions
// external & public view & pure functions

pragma solidity ^0.8.0;

import {IVRFCoordinatorV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol";
import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/* Errors */
error TravelVRFV2Plus__NoRequestFound();
error TravelVRFV2Plus__SubscriptionNotFunded();
error TravelVRFV2Plus__OutofRange(uint32 userRequirementWords, uint32 maxWords);
error TravelVRFV2Plus__CollaboratorExists();
error TravelVRFV2Plus__CollaboratorNotExists();

/* Interfaces, Libraries, and Contracts */

contract TravelVRFV2Plus is VRFConsumerBaseV2Plus {
    event RequestSent(uint256 indexed requestId, uint32 numWords);
    event RequestFulfilled(uint256 indexed requestId, uint256[] randomWords);
    event CollaboratorAdded(address indexed collaborator);
    event CollaboratorRemoved(address indexed collaborator);

    modifier onlyOwnerOrCollaborators() {
        if (msg.sender != owner() && s_collaborators[msg.sender]) {
            revert TravelVRFV2Plus__CollaboratorNotExists();
        }
        _;
    }

    // The RequestStatus struct stores the status of a request.
    struct RequestStatus {
        bool fulfilled; // whether the request has been successfully fulfilled
        bool exists; // whether a requestId exists
        uint256[] randomWords; // the random words generated by the VRF
    }

    IVRFCoordinatorV2Plus COORDINATOR;

    // Your subscription ID.
    uint256 s_subscriptionId;

    // The Coordinators address.
    /**
     * HARDCODED FOR SEPOLIA
     * COORDINATOR: 0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B
     */
    address immutable s_coordinatorAddr;

    // The gas lane to use, which specifies the maximum gas price to bump to.
    // For a list of available gas lanes on each network,
    // see https://docs.chain.link/docs/vrf/v2-5/supported-networks
    // 30 gwei keyhash: 0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d953677ae
    bytes32 immutable s_keyhash;

    // Depends on the number of requested values that you want sent to the
    // fulfillRandomWords() function. Storing each word costs about 20,000 gas.
    uint32 private s_callbackGasLimit = 100_000;

    // The default is 3, but you can set this higher.
    // Cannot exceed VRFCoordinatorV2_5.MAX_REQUEST_CONFIRMATIONS.  [3, 200].
    uint16 private s_requestConfirmations = 3;

    // For this example, retrieve 2 random values in one request.
    // Cannot exceed VRFCoordinatorV2_5.MAX_NUM_WORDS. 	500
    uint32 private s_lastNumWords = 2;

    mapping(uint256 => RequestStatus) private s_requests; /* requestId --> requestStatus */
    mapping(uint256 => uint256[]) private s_shuffleWords; /* requestId --> shuffledWords */

    // past requests Id.
    uint256[] private s_requestIds;
    uint256 private s_lastRequestId;

    // Collaborators can be added or removed by the owner.
    // Collaborators can request random words and receive the results.
    mapping(address => bool) private s_collaborators;

    uint256 private s_minValueOfWord = 1;
    uint256 private s_maxValueOfWord = 6;

    constructor(uint256 subscriptionId, address coordinatorAddr, bytes32 keyhash)
        VRFConsumerBaseV2Plus(coordinatorAddr)
    {
        s_subscriptionId = subscriptionId;
        s_coordinatorAddr = coordinatorAddr;
        s_keyhash = keyhash;
        COORDINATOR = IVRFCoordinatorV2Plus(s_coordinatorAddr);
    }

    // Assumes the subscription is funded sufficiently.
    function requestRandomWords(uint32 _numWords, bool _nativePayment)
        external
        onlyOwnerOrCollaborators
        returns (uint256 requestId)
    {
        // Will revert if subscription is not set and funded.
        // To enable payment in native tokens, set nativePayment to true.
        if (_numWords > 500) {
            // "Number of words requested is out of range. Cannot exceed 500."
            revert TravelVRFV2Plus__OutofRange(_numWords, 500);
        }
        requestId = COORDINATOR.requestRandomWords(
            VRFV2PlusClient.RandomWordsRequest({
                keyHash: s_keyhash,
                subId: s_subscriptionId,
                requestConfirmations: s_requestConfirmations,
                callbackGasLimit: s_callbackGasLimit,
                numWords: _numWords,
                extraArgs: VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1({nativePayment: _nativePayment}))
            })
        );
        s_requests[requestId] = RequestStatus({randomWords: new uint256[](0), exists: true, fulfilled: false});
        s_requestIds.push(requestId);
        s_lastRequestId = requestId;
        s_lastNumWords = _numWords;
        emit RequestSent(requestId, _numWords);
        return requestId;
    }

    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {
        if (!s_requests[_requestId].exists) {
            revert TravelVRFV2Plus__NoRequestFound();
        }
        s_requests[_requestId].fulfilled = true;
        s_requests[_requestId].randomWords = _randomWords;
        // Random word shuffling requires discussion with teammates to handle situations with multiple random words.
        // For now, we will only handle the case of one random word.
        s_shuffleWords[_requestId] = shuffle(s_minValueOfWord, s_maxValueOfWord, _randomWords[0]);
        emit RequestFulfilled(_requestId, _randomWords);
    }

    /* Functions */

    /**
     * @dev Shuffle an array using the Fisher-Yates algorithm.
     * @param start The starting index of the shuffled array. The minimum value of words is set by the s_minValueOfWord variable.
     * @param size The size of the shuffled array. The maximum value of words is set by the s_maxValueOfWord variable.
     * @param entropy The entropy to use for the shuffle.
     */
    function shuffle(uint256 start, uint256 size, uint256 entropy) public pure returns (uint256[] memory) {
        uint256[] memory shuffled = new uint256[](size);

        // Initialize the shuffled array with the indices of the array.
        for (uint256 i = 0; i < size; i++) {
            shuffled[i] = i + start;
        }

        // Shuffle the array using the Fisher-Yates algorithm.
        bytes32 randomness = keccak256(abi.encodePacked(entropy));
        for (uint256 i = size - 1; i > 0; i--) {
            uint256 selected_item = uint256(randomness) % (i + 1);

            // Swap the selected item with the last item of the array.
            uint256 temp = shuffled[i];
            shuffled[i] = shuffled[selected_item];
            shuffled[selected_item] = temp;

            // generate a new randomness for the next iteration.
            randomness = keccak256(abi.encodePacked(randomness));
        }
        return shuffled;
    }

    /* SETTER */

    function setRequestConfirmations(uint16 _requestConfirmations) external onlyOwnerOrCollaborators {
        s_requestConfirmations = _requestConfirmations;
    }

    function setCallbackGasLimit(uint32 _callbackGasLimit) external onlyOwnerOrCollaborators {
        s_callbackGasLimit = _callbackGasLimit;
    }

    /**
     * @dev Set the value range of the shuffled words.
     * @param min The minimum value of the shuffled words.
     * @param max The maximum value of the shuffled words.
     */
    function setValueRangeOfWord(uint256 min, uint256 max) external onlyOwnerOrCollaborators {
        if (min != s_minValueOfWord) {
            s_minValueOfWord = min;
        }
        if (max != s_maxValueOfWord) {
            s_maxValueOfWord = max;
        }
    }

    /* GETTER */

    function getRequestStatus(uint256 _requestId)
        external
        view
        returns (bool fulfilled, uint256[] memory randomWords)
    {
        if (!s_requests[_requestId].exists) {
            revert TravelVRFV2Plus__NoRequestFound();
        }
        RequestStatus memory request = s_requests[_requestId];
        return (request.fulfilled, request.randomWords);
    }

    function getRequestIds() external view returns (uint256[] memory) {
        return s_requestIds;
    }

    function getLastRequestId() external view returns (uint256) {
        return s_lastRequestId;
    }

    function getRequestConfirmations() external view returns (uint16) {
        return s_requestConfirmations;
    }

    function getCallbackGasLimit() external view returns (uint32) {
        return s_callbackGasLimit;
    }

    function getLastRequestNumWords() external view returns (uint32) {
        return s_lastNumWords;
    }

    function getValueRangeOfWord() external view returns (uint256 min, uint256 max) {
        return (s_minValueOfWord, s_maxValueOfWord);
    }

    /* Collaborators */

    function addCollaborator(address _collaborator) external onlyOwnerOrCollaborators {
        if (s_collaborators[_collaborator]) {
            revert TravelVRFV2Plus__CollaboratorExists();
        }
        s_collaborators[_collaborator] = true;
        emit CollaboratorAdded(_collaborator);
    }

    function removeCollaborator(address _collaborator) external onlyOwnerOrCollaborators {
        if (!s_collaborators[_collaborator]) {
            revert TravelVRFV2Plus__CollaboratorNotExists();
        }

        delete s_collaborators[_collaborator];
        emit CollaboratorRemoved(_collaborator);
    }
}
